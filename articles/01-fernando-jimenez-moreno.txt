	1.	What is it?
	2.	Why?
	3.	Who is the audience?
	4.	What are the topics?
	5.	Future
	6.	Feedback/How to participate
	7.	Interview 1 - Fernando
	8.	Interview 2 - Brian Warner

What is it?

We write a lot of software at Mozilla. Some of the software we write is superb and could be held up as a beacon of great software craftsmanship. Some is well.. garbage.

This is the first of a series of interviews that explores the question “How can we write more superb software?”

Instead of waxing poetic about my own take on software quality, I am presenting the highlights of interviews that I have done with several folks from the Mozilla community who are willing to share their view of what it takes to write good software. Quality software is more than just beautiful code and developers are only one part of the overall picture. To gain a holistic picture, I interviewed folks from a variety of roles: Security, Quality Assurance (QA), and of course, developers.

My goal is to learn from some of Mozilla’s finest and spread their wisdom far and wide. We are an open source company, why not open source our knowledge too?

Why?

It’s difficult to write software that “works”. It’s even more difficult to write software that works, that meets a need, is beautiful, and is secure. I want to learn from the best, and I want others to have that opportunity too.

Who is the audience?

If you are reading this, you are among the target audience, no matter what language you develop in or your level of experience. I attempt to ask the interviewees high level questions that can be applied to any language.

What are the topics?

I have specific questions that I want to hear other people’s opinions about:

* How do other developers approach writing high quality, maintainable software?
* What does "high quality, maintainable software" even mean?
* What are my peers looking for when doing code review?
* How does development/Security/QA fit together to support each other’s efforts?
* What matters to Security? What do they look for when doing a security review/audit?
* What matters to QA? What do they look for before signing off on a release?
* What tools are used to ease the burden?
* What can *I* do, as a developer, to write great software and facilitate the entire process?

How will the articles be structured?

In each article, I will present the highlights of one or two interviews. Each interview will contain a short introduction to the person being interviewed, and a series of questions and their answers.

Where an interview’s audio was recorded, I will provide a link to the full transcript. If the interview was done over email, I will link to the contents of the original email.

Now, on to the first two interviewees.

==============================

The first interviewee is Fernando Jimenez Moreno, a FirefoxOS developer from Telefonica. I had the opportunity to work with Fernando last autumn when we integrated Firefox Accounts into First Time Experience of FirefoxOS. I was always impressed not only with Fernando’s technical prowess, but also his ability to bring together the employees of three companies in four cities on two continents to work towards a common goal.

Fernando’s interview is focused on how to bring a disparate group together under a common goal, common standards, code reviews, and being pragmatic.

—————————————————————————

S: What do you and your team at Telefonica do?

F: I’m part of what we call the platform team. We have different teams at Telefonica, one is focused on front end development in Gaia, and the other one is focused on the platform itself, like Gecko, Gonk and external services. So we work in several parts of the FirefoxOS stuff, from Gecko to Gaia, to services like the SimplePush server. I’ve personally worked on things like the REL interface layer, payments, applications API and other Web APIs, and almost always jumping from Gecko to Gaia and back. Most recently, I started working on this Loop project, which like I said, is Telefonica and Mozilla’s WebRTC service.

S: How do you work with Mozilla, and how did Telefonica get involved working with Mozilla?

Well, that’s a longer story. How did we get involved? Well, we started working on a similar project as FirefoxOS, but instead of being based on Gecko, we were working with WebKit. So we were creating this open web device platform based on WebKit. When we heard about Mozilla doing the same with Gecko, we decided to contact you and started working on the same thing. Our previous implementation was based on a closed source port of WebKit and it was really hard to work that way. Since then, my day to day work is just like any other member of Telefonica’s FirefoxOS team, which I believe is pretty much the same as any other Mozilla engineer working on B2G.

S: You are known as a great architect, developer, and inter-company coordinator. For Firefox Accounts on FirefoxOS, you brought together people from Telefonica, Telenor, and Mozilla. What challenges are present when you have to work across three different companies?

F: It has given me quite a challenge and experience, especially during the first days of FirefoxOS. We started working with Mozilla back in 2011, and it took some time for both companies to find a common work flow that fit well for both parts. I mean, we were coming from a telco culture where many things were closed and confidential by default, as opposed to the openness and transparency of Mozilla. For some of us coming from other open source projects, it wasn’t that hard to start working in the open and to be ready to discuss and defend our work on public forums. But, for other members of the team it took some time to get used to that new way of working, and new way of presenting our work. Also, because we were following agile methodologies in Telefonica while Mozilla wasn’t still doing it, we had to find this common workflow that suits both parts. It took some time to do it, a lot of management meetings, a lot of discussions about it. Regarding working with other telco companies, the experience has also been quite good so far, especially with Telenor. We still have to be careful about the information that we share with them, because at the end of the day, we are still competitors. But that doesn’t mean we cannot work with them in a common target like what happened with Firefox Accounts.

S: It sounds like basically in 2011 and earlier on, when Mozilla and Telefonica were both starting out on this process, both sides had to change. Some people at Telefonica had to get used to working in the open, and some people at Mozilla had to change their methodologies. You mentioned agile in particular. How did you decide what common practices to use and how did you establish a common culture to get everybody to go together?

F: I think for this agile methodology, we focused more on the front end parts because as you said, Gecko already has a very known process and a very known way of developing. It has it’s own train mechanism of 6 weeks. As I said, we have two different teams in Telefonica, the platform team and the front end team. The ones doing the most, the biggest effort of finding that common workflow were the front end team because we started working on Gaia and Gaia was a new project with no fixed methodologies. They tried to find the common methodology for Gaia. In the meantime, the people working on the task were trying to learn the Gecko process and also we are in the middle between working with the Gaia team and working with Gecko engineers. I don’t know if we really found the workflow, the perfect workflow, but I think we are doing good. I mean we participate in agile methodologies, but when it turns out that we need to do Gecko development and we need to focus on that, we just do it their way.

S: In a multi-disciplinary, multi-company project, how important are common standards like style guides, tools, and processes to making a project succeed?

F: Well, I believe when talking about software engineering, standards are very important in general. But, I don’t care if you call it SCRUM or KANBAN or SCRUMBAN or whatever, or if you use Git workflow or Mercurial workflow, or if you use Google or Mozilla’s Javascript style guide. But you totally need some common processes and standards, especially in large engineering groups like open source, or Mozilla development in general. When talking about this, the lines are very thin. It’s quite easy to fail spending too much time defining and defending the usage of these standards and common processes and losing the focus on the real target. So, I think we shouldn’t forget these are only tools, they are important, but they are only tools to help us, and help our managers. We should be smart enough to be flexible about them when needed. We do a lot of code reviews about code style, but in the end what you want is to land the patch and to fix the issue. If you have code style issues, I want you to fix them, but if you need to land the patch to make a train, land it and file a follow on bug to fix the issues, or maybe the reviewer can do it if they have the chance.

S: Whenever new people come into the project, how can you go about educating them about the standards that already exist?

F: I would say, at first, documentation. But, you probably suffered the lack of documentation about it. So, I guess reviews and day to day work, where people are already familiar with these standards participate in this education process. There are also tools like linters or git and mercurial hooks to enforce some of these standards.

S: FirefoxOS code is Gonk, which is linux basically, Gecko and Gaia. Each system is large, complex, and intimidating to a newcomer. I feel Gecko in particular is intimidating. You regularly submit patches to Gecko and Gaia. You had to learning about all of these systems somehow. Whenever you want to go dive into a project, how do you go about learning the system you are getting ready to dive into?

F: I’m afraid there is no magic technique. What works for me might not work for others for sure. So, what I try to do is to read as much documentation as possible inside and outside of the code, if it’s possible. I try to ask the owners of that code when needed, and also if that’s possible, because sometimes they just don’t work in the same code or they are not available. I try to avoid reading the code line by line at first and I always try to understand the big picture before digging into the specifics of the code. I think that along the years, you somehow develop this ability to identify patterns in the code and to identify common architectures that help you understand the software problems that you are facing.

S: When you start coding in unfamiliar territory, how do you ensure your changes don’t cause unintended side effects? Is testing a large part of this?

F: Yeah, basically tests, tests and more tests. You need tests, smoke tests, black box tests, tests in general. Also at first, you depend a lot on what the reviewer said, and you trust that the reviewer, or you can ask QA or the reviewer to add tests to the patch.

S: Let’s flip this on its head and you are the reviewer and you are reviewing somebody’s code. Again, do you rely on the tests whenever you say “OK, this code adds this functionality. How do we make sure it doesn’t break something over there?”

F: I usually test the patches that I have review if I think the patch can cause any regression. I also try and run the tests on the “try” server, or ask the developer to trigger a “try” run.

S: OK, so tests.. A lot of tests.

F: Yeah, now that we are starting to have good tests in FirefoxOS, we have to make use of them.

S: I feel like there is this tension between what level of test to write. Some people say “unit tests are worthless because if the interface changes then you have to go update all the tests and functional tests are where it’s at.” And other people are like “nooo, you’ve gotta unit test everything and functional tests won’t tell you where the problem is, it’ll only tell you there is problem.” I would love to write huge numbers of both, but sometimes there is not enough time. I don’t know if that’s a false assumption on my part. How do you deal with testing in time constrained situations. Do you try to do both functional tests and unit tests? If you had to ditch one, where do you focus your testing efforts?

F: I guess it depends on the time that you have for the coding part. I usually approach it, I think the wrong way. I write the code then write the tests, when I should probably do the opposite. I think it’s this urge to see something working. Because that’s actually your job to make the patch work, and then you need to make sure it’s well written and it works well and it doesn’t break so you write the tests for it. But, I guess, I don’t know which tests I would choose first. I mean functional tests are done to assure that your code works as suspected, but you can also rely on your personal tests on the device, and your manual tests. So you can probably avoid writing functional tests at first and focus on unit tests that tests only specific functionality of the code, specific parts of the code. I don’t know which one I would choose, it depends on the patch and the time that I have. I also ask “what would the reviewer ask me to write?” I mean, we all love tests, and we would all like to write as much tests as possible, but in the end we have a lot of patches to write and we just want the patch to be landed. We need to make the reviewer happy, if he wants this test, I will write this test. That’s it.

S: Memory management is something developers have not had to worry about since Internet Explorer was losing circular references back in IE6 and IE7. On a resource constrained device like a low end FirefoxOS phone, we have to worry about this stuff again. Has this focus on memory management changed the way that you write apps, and if so, how? And, has it changed the way you write normal web apps for a normal browser?

F: When you write the web apps, you don’t really need to worry about memory management in terms of it’s hard to leak memory when writing a web application. You trust the browser trying to do the right thing, but yeah, absolutely. Memory constraints, I think affect the way you design your software and the way you write your code. I mean things like lazy loading or cleanup routines are well known, good practices. Cleanup routines mean you have to release unused objects or if you are using cache, you have to release them. You have to clean it if you are not using it, it’s common sense writing code right. In FirefoxOS, not only looking for the memory footprint, but also for improved performance. In FirefoxOS, we have a lot of issues with the first paint event, we have to make sure that the launch path is as fast as possible so the user gets feedback as soon as possible, so you have to write your code with that in mind. You have to lazy load stuff, show things as fast as possible. Also, you have to be aware in FirefoxOS, your application can be killed at any point in its life cycle, so that your app should be ready to recover from that situation. That affects the way you write your code.

S: Has that affected how you do development for other web pages, for non FirefoxOS web pages?

F: Well, I think it’s also beneficial for web applications running on other platforms, but since FirefoxOS is the low end platform for web applications, it’s the best platform to test your working. You will suffer there.

S: So you mentioned the cleanup routines. It’s something that I feel is under appreciated in web development. I feel that people have a grasp on lazy loading, but a lot of people still don’t understand that they should clean up their references whenever an object goes away. I haven’t seen very many articles or people talking about why.

F: It also depends on the garbage collector. Maybe it’s platform specific also. You thought it’s hard to write your code for a specific implementation of the browser, and you just need to use the profiler in that case. It’s hard to think about the garbage collection when you need to release references, but usually you need to use, to do it, when you don’t need it. Basically, it’s common sense. And also the event listeners and all this stuff that’s taking memory and you are not using it.

S: When Firefox Accounts work first started, I showed up a day late and you guys had the API to talk between Gaia and Gecko defined, and that has been the bedrock of communication between Firefox Accounts and the system app. Developers often hate doing up front design, they just like to do it as they go along, but when have you found early API design like that helpful, and have you ever found that can hinder things and make it more difficult?

F: I don’t like to put labels on these kinds of things. I really, what we did with Firefox Accounts for FirefoxOS was more like, minimal design up front, rather than a big design up front. We actually proposed different architectures and iterated over them along the work week, trying to find the best approach to the problems we had at that point, but what.. in any case, I guess what approach you take depends on how much time you can spend on the design itself or in the development part itself, and how flexible you are, or the project or the problem, or the problem can be changed later if it’s needed. In general I like to think about the details in advance is quite beneficial in saving a lot of time in refactoring it. So, I think that’s what we did there in Madrid for Firefox Accounts. We put up different options and we tried to evolve these differing options, and we ended up choosing the, what we thought was the best one.

S: What do you look for when you are doing a review?

F: In general where I look first is correctness. I mean, the patch should actually fix the issue it was written for. And of course it shouldn’t have collateral effects. It shouldn’t introduce any regression.  And as I said, I try to test the patches myself if I have the time or if the patch is critical enough, to see how they work and to see if they introduce any regression. And also I look that the code is performant and is secure, and also if, I always try to ask for tests if I think they are possible to write for the patch. And I finally look for things like quality of the code in general, and documentation, coding style, contribution, process correctness. If you have to squash your commits for pushing it to Gaia, then well, you have to do it. Or if you have to write the commit message with the reviewer name, or the bug number, then you have to do it because it’s the process for that project.

S: Whenever you are reviewing code, say it’s a large patch, would you prefer that patch be broken up into smaller commits that show the developer’s process, or do you like to see one giant thousand line patch?

F: I prefer it to be split between different commits. I usually actually write the code that way. I do different patches with different numbers for each patch, that way I think you can even ask for review of different reviewers for each different part because sometimes you will write for B2G but it also involves Gonk parts, or Gecko parts, or Gaia parts, and the same reviewer cannot review the whole stack, so you need to split it into different pieces.

S: And then say, you did have one of these patches that was 3 different commits. Before that got merged, would you squash those into one commit and then merge it?

F: I usually ask the developer to do it, to squash it, or sometimes they do it themselves.

S: You reviewed one of my large patches which was to integrate Firefox Accounts into B2G. You placed much more of an emphasis on consistency than any review I have had. By far.

F: Well it certainly helps with overall code quality. When I do reviews these kinds of comments as “nit:” which is quite common in Mozilla, meaning that “I would like to see that changed, but you still get my positive review if you don’t change it, but I would really like to see them changed.”

S: Two part question. As a reviewer, how can you ensure that your comments are not taken too personally by the developer? The second part is, as a developer, how can you be sure that you don’t take it too personally?

F: For the record, I received quite a few hard revisions myself. And I never take them personally. I mean, I always try to take it, the reviews as positive learning experience, because I know reviewers usually don’t have a lot of time to, in their life, to do reviews. They also have to write code or a lot of things in their work. So, they just quickly write “needs to be fixed” without spending too much time thinking about the nicest ways to say it. And it’s actually funny because the absence of comments in a review. I mean, reviewers only say things about negative things in your code, not negative, but things that they consider are not correct. But they don’t usually say that the things that are correct in your code and I know that can be hard at first. But once you start doing it, you understand why they don’t do that. I mean, you have your work to do. This is actually especially hard for me, being a non-native English speaker, because sometimes I try to express things the nicest way possible but the lack of works make the review comments sound stronger than it was supposed to be. And, what I try to do is use a lot of smileys if possible. And always, I try to avoid the “r-“ flag if I mean, the “r-“ is really bad. I just clear it, use use the “feedback +” or whatever.

S: You already mentioned that you try to take it as a learning experience whenever you are developer. Do you use review as a potential teaching moment if you are the reviewer?

F: Yeah, for sure. I mean just the simple fact of reviewing a patch is a teaching experience. I mean, you are telling the coder what you think is more correct, but sometimes at least I do a. There is a lack of theory and reasons behind that comments, and it’s because of that, the lack of time to express the reasons to make it even nicer. We should all do that, we should explain the reasons and try to make the process as better as possible.


==============================

